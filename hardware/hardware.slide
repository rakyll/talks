Go + Hardware

Jaana Burcu Dogan
Google

jbd@golang.org
@rakyll

* Layers of software in hardware

.image img/stack.png _ 800

: What do we mean by including Go into hardware projects?
: It means we want to communicate with a sensor, display or any other external device from a Go program.
: Industry has standard protocols for the communication/transmission work such as GPIO.
: In the scope of this talk, we will talk about creating core abstractions for the Go language all the way from your Go program to an external device.
: Here is a stack that explains all the layers from your Go program down to the actual external device.
: I want to point out a couple of them.

* Why to include Go into hardware projects?

- Go is efficient, fast and has low memory footprint.
- Out-of-the-box cross compilation.
- A language makes I/O programming fun.
- Go programs compile to static binaries, distribution is easy.
- Cgo is productive where porting is costly.

: I have started to program in Go to write hardware controllers originally.
: Soon, I have realized I am not the only one.
: Some of the major points I always praised was a couple of items listed here.
: Go through the list.

* The current state of the community

- Successful existing solutions (e.g. gobot, hwio, embd, etc).
- Lack of common interface.

: We know that Go is great when third-party libraries can cooperate, existing libraries cannot.
: Second problem is, some libraries are not portable (e.g. works only against devfs).
: I don't want to rewrite the entire program because I want to target a different operating system/platform.
: More to do.
: Existing libraries can be less verbose, more idiomatic, etc.
: Need help with documentation, end-to-end tutorials, etc.

* Peripheral I/O for Go

.image img/iopkg.png _ 800

(Current experimentation is at [[https://golang.org/x/exp/io]])

: We started an official package experiment under x/exp/io.
: These will hold the core abstractions.

* Peripheral I/O for Go (cont.)

Each protocol package contains

- user facing APIs
- driver interface
- a set of popular driver implementations (e.g. devfs, sysfs, firmata)

* Peripheral I/O for Go (cont.)

Let's take a closer look at the user facing APIs vs drivers for I2C.

[[https://golang.org/x/exp/io/i2c]]

* Peripheral I/O for Go (cont.)

Open a connection to an i2c device via devfs while keeping the rest of the code portable.

  import "golang.org/x/exp/io/i2c"

  // devfs specific backend
  devfs := &i2c.Devfs{Dev: "/dev/i2c-1"}

  // portable code...
  device, err := i2c.Open(devfs, 0x39)
  if err != nil {
      panic(err)
  }
  if err := device.WriteReg(0x04, 0x40, 0x40); err != nil {
      panic(err)
  }

* Goals

Provide a downstream protocol library with core abstractions. Propose an official package. GPIO, SPI, I2C and UART are first.

- Focus on portability.
- Provide extendability, composability, chainability.
- Provide common backends, e.g. devfs, sysfs, firmata.
- Apply the interfaces to the high-level libraries such as Gobot.

Deliver strategies for integration testing.

Deliver end-to-end guides.


* How to contribute?

- GPIO package is under construction, wait for it to be finalized.
- Write code against I2C and SPI and let us know.
- Experiment by writing device drivers.
- File bugs at [[https://golang.org/issues]].

: The design process is taking a while because we don't want to break the APIs ever.
: Even though some of the procotols are well defined, we want to consider PWM in the scope and see if .
