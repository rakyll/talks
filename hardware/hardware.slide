Go + Hardware

Jaana Burcu Dogan
Google

jbd@golang.org
@rakyll

* TODO: stack

: What do we mean by including Go into hardware projects?
: It means we want to communicate with a sensor, display or any other external device from a Go program.
: Industry has standard protocols for the communication/transmission work such as GPIO.
: In the scope of this talk, we will talk about creating core abstractions for the Go language all the way from your Go program to an external device.

* Why to include Go into hardware projects?

- Go is efficient, fast and has low memory footprint.
- Out-of-the-box cross compilation.
- A language makes I/O programming fun.
- Go programs compile to static binaries, distribution is easy.
- Cgo is productive where porting is costly.

* The current state

- Successful existing solutions (e.g. gobot, hwio, embd, etc).
- Lack of common interface.

: We know that Go is great when third-party libraries can cooperate, existing libraries cannot.
: Second problem is, some libraries are not portable (e.g. works only against devfs).
: I don't want to rewrite the entire program because I want to target a different operating system/platform.
: More to do.
: Existing libraries can be less verbose, more idiomatic, etc.
: Need help with documentation, end-to-end tutorials, etc.

* Peripheral I/O for Go

.image img/iopkg.png _ 800

(Current experimentation is at [[https://golang.org/x/exp/io]])

: We started an official package experiment under x/exp/io.
: These will hold the core abstractions.

* Peripheral I/O for Go (cont.)

Each protocol package contains

- user facing APIs
- driver interface
- a set of popular driver implementations (e.g. devfs, sysfs, firmata)

* Peripheral I/O for Go (cont.)

Let's take a closer look at the user facing APIs vs drivers for I2C.

[[https://golang.org/x/exp/io/i2c]]

* Peripheral I/O for Go (cont.)

How to open a connection to an i2c device via devfs while keeping
the rest of the code portable.

  import "golang.org/x/exp/io/i2c"

  // devfs specific backend
  devfs := &i2c.Devfs{Dev: "/dev/i2c-1"}

  // portable code...
  device, err := i2c.Open(devfs, 0x39)
  if err != nil {
      panic(err)
  }
  if err := device.WriteReg(0x04, 0x40, 0x40); err != nil {
      panic(err)
  }

* Goals

Defrag the library space. Propose an official package. GPIO, SPI, I2C and UART are first.

- Focus on portability.
- Provide extendability, composability, chainability.
- Provide common backends, e.g. devfs, sysfs, firmata.
- Enable portable community driven high-level device drivers.

Deliver strategies for integration testing.

Deliver end-to-end guides.

* High-level device drivers

TODO

* How to contribute?

- GPIO package is under construction, wait for it to be finalized.
- Write code against I2C and SPI and let us know.
- Contribute to [[http://github.com/goiot/devices]].
- File bugs at [[https://golang.org/issues]].

* Demo

* When not to include Go?

: hello world
: hello

- Where you can't include (e.g. not supported OS/arch).
- Strict CPU and memory constraints.
- Realtime constraints.

 TODO