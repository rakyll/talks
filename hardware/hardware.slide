Go for Hardware Projects

Jaana Burcu Dogan
Google

jbd@golang.org
@rakyll

* Disclaimer

The scope of this talk is mainly about peripheral protocols such as GPIO. Many other topics to consider in the future:

- tooling
- support of new generation network protocols (e.g. CoAP)
- testing utilities
- perf/diagnostics tools

* Why to include Go into hardware projects?

- Go is efficient, fast and has low memory footprint.
- Out-of-the-box cross compilation.
- A language makes I/O programming fun.
- Go programs compile to static binaries, distribution is easy.
- Cgo is productive where porting is costly.

* When not to include Go?

Most items are obvious.

- Where you can't include (e.g. not supported OS/arch).
- Strict CPU and memory constraints.
- Realtime constraints.

* The current state

- The community is fragmented (e.g. gobot, hwio, embd, etc).
- Libraries are verbose, non-idiomatic, etc.
- Some libraries are not portable (e.g. works only against devfs).
- Go is great when third-party libraries can be cooperative, peripheral libraries cannot.
- Lacking documentation, end-to-end tutorials, etc.

* Goals

Make Go a to-go language for hardware projects.

Defrag the library space. Propose an official package. GPIO, SPI and I2C are first.

- Focus on portability.
- Provide extendability, composability.
- Enable portable community driven high-level device drivers.

Deliever end-to-end guides.

Deliver strategies for integration testing.

(Note: Current experimentation is at [[https://golang.org/x/exp/io]])

* A first look

* How to contribute?

* Demo
