A Proposal: Peripheral I/O for Go

Jaana Burcu Dogan
Google

jbd@golang.org
@rakyll

* What? Peripheral? ðŸ¤”

.image img/profiterols.png _ 800

* Peripheral devices

External devices such as input and output devices are peripheral devices.

.image img/peripheral-device.jpg _ 550

* Peripheral protocols

Why do we need to care about peripheral protocols?

Make Go a better language for hardware projects.

* GPIO

General purpose programmable pins (usually between 0V-5V)

.image img/gpio.png _ 650

* I2C

Or high-level protocols can be programmed on GPIO pins such as I2C

.image img/i2c.png _ 650

* Why to include Go into hardware projects?

- Go is efficient, fast and has low memory footprint.
- Out-of-the-box cross compilation.
- A language makes I/O programming fun.
- Static binaries, distribution is easy.
- Cgo is productive if porting C/C++ libs is not an option.

: I have started to program in Go to write hardware controllers originally.
: Soon, I have realized I am not the only one.
: Some of the major points I always praised was a couple of items listed here.
: --Go through the list.

* Software stack in hardware projects

.image img/layers.png _ 800

: What do we mean by including Go into hardware projects?
: It means we want to communicate with a sensor, display or any other external device from a Go program.
: Industry has standard protocols for the communication/transmission work such as GPIO.
: In the scope of this talk, we will talk about creating core abstractions for the Go language all the way from your Go program to an external device.
: Here is a stack that explains all the layers from your Go program down to the actual external device.
: I want to point out a couple of them.


* The current state

- Successful existing solutions (e.g. gobot, hwio, embd, etc).
- Lack of common interface.

: We know that Go is great when third-party libraries can cooperate, existing libraries cannot.
: We need to address the issue with common core abstractions.
: Second problem is, some libraries are not portable (e.g. works only against devfs).
: I don't want to rewrite the entire program because I want to target a different operating system/platform.
: And there is more to do.
: Existing libraries can be less verbose, more idiomatic, etc.
: Need help with documentation, end-to-end tutorials, etc.

* Why to have common interfaces?

Fix the fragmentation.

Make libraries portable, extendable, composable.

* Peripheral I/O for Go

.image img/iopkg.png _ 800

(Current experimentation is at [[https://golang.org/x/exp/io]])

: We started an official package experiment under x/exp/io.
: These will hold the core abstractions.

* Why drivers?

.image img/piolayers.png _ 800


* Peripheral I/O for Go (cont.)

Each protocol package contains

- user facing APIs
- driver abstractions
- a set of popular driver implementations (e.g. devfs, sysfs, firmata)


* Peripheral I/O for Go (cont.)

Open a connection to an i2c device via devfs while keeping the rest of the code portable.

  import "golang.org/x/exp/io/i2c"

  // devfs specific backend
  o := &i2c.Devfs{Dev:"/dev/i2c-1"}

  // portable code...
  device, err := i2c.Open(o, 0x39)
  if err != nil {
      panic(err)
  }
  if err := device.WriteReg(0x04, 0x40, 0x40); err != nil {
      panic(err)
  }

* Goals

Provide a downstream protocol library with core abstractions. Propose an official package. GPIO, SPI, I2C and UART are first.

- Focus on portability.
- Provide extendability, composability, chainability.
- Provide common backends, e.g. devfs, sysfs, firmata.
- Apply the interfaces to the high-level libraries such as Gobot.

Deliver strategies for integration testing.

Deliver end-to-end guides.


* How to contribute?

- GPIO package is under construction, wait for it to be finalized.
- Write code against I2C and SPI and let us know.
- Experiment by writing device drivers, examples at [[https://github.com/goiot/devices]].
- File bugs at [[https://golang.org/issues]].

: The design process is taking a while because we don't want to break the APIs ever.
: Even though some of the procotols are well defined, we want to consider PWM in the scope and see if .
